---
title: MySQL
tags:
  - MySQL面试题
createTime: 2023/03/27 16:05:16
permalink: /interview/mysql/
---
# 1.事务

**什么是事务？**

由多个操作组成的一个逻辑单元，组成这个逻辑单元的多个操作要么都成功，要么都失败。

> 事务原则 ACID 原子性、一致性、隔离性、持久性

**Atomicity原子性：**要么全部成功,要么全部失败，不可能只执行一部分操作。

**Consistency一致性：**系统(数据库)总是从一个一致性的状态转移到另一个一致性的状态,不会存在中间状态。

**Isolation隔离性:** 通常来说:一个事务在完全提交之前,对其他事务是不可见的.注意前面的通常来说加了红色,意味着有例外情况。

**Durability持久性：**一旦事务提交,那么就永远是这样子了,哪怕系统崩溃也不会影响到这个事务的结果。



# 2.并发事务带来哪些问题？

> **脏读：**“就是事务读取到的数据是未修改的旧数据”

当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”



> **幻读：**“就是指同一个事务在执行读取操作的时候，前后两次的读取，出现了原本没有出现的数据，是因为两次读取中间其他事务进行了修改“

发现多了一些原本不存在的记录



> **不可重复读：**“就是指同一个事务读取同一个数据两次的结果不一致，是因为被其他事务在两次读取的过程中将数据修改了”

在一个事务内两次读到的数据是不一样的情况。



> **丢失修改：**“就是指两个事务对同一个数据都进行了修改，前者执行修改的事务修改完后的数据被后面执行的事务将数据再次修改，致使，前面执行的事务的修改结果就丢失了”

指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。



## 怎么解决这些问题呢？MySQL的默认隔离级别是？

解决方案：**对事务进行隔离**



**四种隔离级别：**

> **未提交读**(READ	UNCOMMITTED)：

其他事务可以看到本事务没有提交的部分修改，因此会造成脏读的问题（读取到了其他事务未提交的部分,而之后该事务进行了**回滚**）

> **已提交读**(READ	COMMITTED)：

事务只能读取本事务已经提交过的数据，有不可重复读的问题

> **可重复读**(REPEATATATABLE	READ)：默认隔离级别，解决了不可重复读的问题，没有解决幻读的问题，使用锁实现，多个事务可以同时读取的同一个数据，但是会被锁定，不允许其他事务修改数据



> **SERIALIZABLE(可串行化)：**这是最高的隔离级别,可以解决上面提到的所有问题,因为他强制将所以的操作串行执行,这会导致并发性能极速下降,因此也不是很常用。



# 3.索引

[CodingLabs - MySQL索引背后的数据结构及算法原理](http://blog.codinglabs.org/articles/theory-of-mysql-index.html)

**索引**（index）是帮助MySQL高效获取数据的数据结构(有序)

“数据库存储的数据会按照使用指定的索引（数据结构）进行存储，后续查找数据的时候，按照存储时使用的索引（数据结构）查找”

## 索引的底层数据结构了解过嘛

MySQL默认使用的索引底层数据结构是**B+树**。

**红黑树：**自平衡二叉树

**B-Tree：**B树是一种多叉路衡查找树，相对于二叉树，B树每个节点可以有多个分支，即多叉。



## 索引的分类？





# 4.什么是聚簇索引？什么是非聚簇索引？

**聚簇索引：**将数据存储与索引放到了一块，索引结构的叶子节点保存了**行数据**

**非聚簇索引：**将数据与索引分开存储，索引结构的叶子节点关联的是对应的**主键**



一个表中一定存在聚簇索引，但是不一定存在非聚簇索引（辅助索引），当然这里这是针对InnoDB存储引擎而言。



主键聚集，所以InnoDB要求表必须有主键（MyISAM可以没有），如果没有显式指定，则MySQL系统会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整形。



聚集索引这种实现方式使得按主键的搜索十分高效，但是辅助索引搜索需要检索两遍索引：首先检索辅助索引获得主键，然后用主键到主索引中检索获得记录。

# 5.索引是什么时候被用到的？

- 跟where条件有关，如果条件中的判断是包含索引（的一部分，即联合索引）时就会被用到
- 联合索引，是满足**左前缀原则**





# 6.一个SQL语句执行很慢,	如何分析 ?

可以采用EXPLAIN 或者  DESC命令获取  MySQL 如何执行  SELECT 语句的信息，包括在  SELECT 语句执行过程中表如何连接和连接的顺序。

```sql
-- 直接在select语句之前加上关键字 
explain / descEXPLAIN SELECT 字段列表 FROM 表名 WHERE 条件 ;
```



# 7.什么情况下索引会失效 ？

- 1、**最左前缀**法则：
  - 违法最左前缀法则 ， 索引失效；
  - 如果符合最左法则，但是出现跳跃某一列，只有最左列索引生效
- 2、范围**查询右边的列**，不能使用索引：
- 3、不要在索引列上进行**运算操作**， 索引将失效。
- 4、字符串**不加单引号**，造成索引失效。
- 5、尽量**使用覆盖索引**，避免select *
- 6、**用or分割开的条件**， 如果or前的条件中的列有索引，而后面的列中没有索引，那么涉及的索引都不会被用到。
- 7、以**%开头的Like**模糊查询，索引失效。如果仅仅是尾部模糊匹配，索引不会失效。如果是头部模糊匹配，索引失效。-----通过覆盖索引来解决
- 8、如果MySQL评估使用索引比全表更慢，则不使用索引。
- 9、 **is NOT NULL** 有时索引失效。
-  10、**in** 走索引，  **not in** 索引失效。



# 8.谈谈你对sql的优化的经验

1. 表的**设计优化**
   - 选择表合适存储引擎：
   - 选择合适的数据类型
2. **索引优化**
   - 表的主键、外键必须有索引；
   - 数据量大的表应该有索引；
   - 经常与其他表进行连接的表，在连接字段上应该建立索引；
   - 经常出现在Where子句中的字段，特别是大表的字段，应该建立索引；
   - 索引应该建在选择性高的字段上； （sex 性别这种就不适合）
   - 索引应该建在小字段上，对于大的文本字段甚至超长字段，不要建索引；
   - 频繁进行数据操作的表，不要建立太多的索引；
   - 删除无用的索引，避免对执行计划造成负面影响；
3. **SQL 语句的优化**
   - SELECT 语句务必指明字段名称（避免直接使用 select *）
   - SQL 语句要避免造成索引失效的写法
   - SQL 语句中 IN 包含的值不应过多
   - 当只需要一条数据的时候，使用limit 1
   - 如果排序字段没有用到索引，就尽量少排序
   - 如果限制条件中其他字段没有索引，尽量少用 or
   - 尽量用 union all 代替 union
   - 避免在 where 子句中对字段进行 null 值判断
   - 不建议使用 % 前缀模糊查询
   - 避免在 where 子句中对字段进行表达式操作
   - Join 优化能用 innerjoin 就不用left join right join，如必须使用 一定要以小表作为驱动
4. **主从复制、读写分离**
   - 写分离，解决的是，数据库的写入，影响了查询的效率。读写分离的基本原理是让主数据库处理事务性增、改、删操作（INSERT、UPDATATE、DELETE），而从数据库处理SELECT查询操作。
5. MySQL **分库分表**









# 9.Mysql为什么要分库分表？分库分表的策略有哪些？

1. **IO瓶颈**：热点数据太多，数据库缓存不足，产生大量磁盘IO，效率较低。 请求数据太多，带宽不够，网络IO瓶颈。
2. **CPU瓶颈**：排序、分组、连接查询、聚合统计等SQL会耗费大量的CPU资源，请求数太多，CPU出现瓶颈。



分库分表的中心思想都是将数据分散存储，使得单一数据库/表的数据量变小来缓解单一数据库的性能问题，从而达到提升数据库性能的目的。

> **拆分策略：垂直和水平**

**垂直拆分：**

> 垂直分库：依表为依据

- 每个库的表结构都不一样。

- 每个库的数据也不一样。

- 所有库的并集是全量数据。

> 垂直分表：依字段为依据

- 每个表的结构都不一样。

- 每个表的数据也不一样，一般通过一列（主键/外键）关联。

- 所有表的并集是全量数据。



**水平拆分：**

> 水平分库：依字段为依据

- 每个库的表结构都一样。
- 每个库的数据都不一样。
- 所有库的并集是全量数据。



> 水平分表：依字段为依据

- 每个表的表结构都一样。
- 每个表的数据都不一样。
- 所有表的并集是全量数据。



## 实现技术

- shardingJDBC：基于AOP原理，在应用程序中对本地执行的SQL进行拦截，解析、改写、路由处理。需要自行编码配置实现，只支持java语言，性能较高。
- MyCat：数据库分库分表中间件，不用调整代码即可实现分库分表，支持多种语言，性能不及前者。



## 分库分表后id主键如何处理

- 主键自增：数据库中间件可以设置主键的自增
- UUID好处就是本地生成，不要基于数据库来了；不好之处就是，UUID 太长了、占用空间大，作为主键性能太差 了；更重要的是，UUID 不具有有序性，会导致  B+ 树索引在写的时候有过多的随机写操作，不能产生有顺序的  append 操作，而需要进行  insert操作，将会读取整个  B+ 树节点到内存，在插入这条记录后会将整个节点写回磁盘，这种操作在记录占用空间比较 大的情况下，性能下降明显
- snowflake 算法





# 10.snowflake 雪花算法

**一种分布式主键ID生成的解决方案**：生成后是一个 64bit 的 long 型的数值，组成部分引入了时间戳，基本保持了自增。

**优点：**

| 优点         | 解释                                   |
| :----------- | :------------------------------------- |
| 高性能高可用 | 生成时不依赖于数据库，完全在内存中生成 |
| 高吞吐       | 每秒钟能生成数百万的自增 ID            |
| ID 自增      | 存入数据库中，索引效率高               |

**缺点：**

依赖服务器时间，服务器时间回拨时可能会生成重复 id。

> 在获取时间的时候，可能会出现**时间回拨**的问题，什么是时间回拨问题呢？就是服务器上的时间突然倒退到之前的时间。

1. 人为原因，把系统环境的时间改了；
2. 有时候不同的机器上需要同步时间，可能不同机器之间存在误差，那么可能会出现时间回拨问题。



## 实现

雪花结构如下：

![雪花算法](resources\雪花算法.png)

**固定值：**

> 1bit，最高位是符号位，0 表示正，1 表示负，固定为 0，如果是 1 就是负数了。

**时间戳：**

> 41bit，存储毫秒级时间戳（41 位的长度可以使用 69 年）。

**标识位（存储机器码）：**

> 10bit，上面中的 机器id（5bit）和 服务id（5bit）统一叫作“标识位”，两个标识位组合起来最多可以支持部署 1024 个节点。

**序列号：**

> 12bit，用于表示在同一毫秒内生成的多个ID的序号。如果在同一毫秒内生成的ID超过了4096个（2的12次方），则需要等到下一毫秒再生成ID。 





# 11.Mysql中有哪几种锁？

按照锁的粒度分，分为以下三类：

- 全局锁：锁定数据库中的**所有表**。
- 表级锁：每次操作锁住**整张表**。
- 行级锁：每次操作锁住对应的**行数据**。



# 12.表级锁和行级锁了解吗？有什么区别？

**表级锁**，每次操作锁住整张表。锁定粒度大，发生锁冲突的概率最高，并发度最低。应用在MyISAM、InnoDB、BDB等存储引擎中

**行级锁**，每次操作锁住对应的行数据。锁定粒度最小，发生锁冲突的概率最低，并发度最高。应用在InnoDB存储引擎中。



# 13.意向锁有什么作用？

为了避免DML在执行时，加的行锁与表锁的冲突，在InnoDB中引入了意向锁，使得表锁不用检查每行数据是否加锁，使用意向锁来减少表锁的检查。



# 14.共享锁（S）和排他锁（X）呢？

>  **什么是共享锁？什么是排他锁？**

共享锁也被称为读锁，排他锁也被称为写锁。

**共享锁：** 如果事务T对数据对象A加上S锁，则可以读A但不能修改A，其他事务只能再对A加S锁，而不能加X锁。这保证了其他事务可以读取A，但在事务T释放对象A上的S锁之前不能对A做任何修改。

**排他锁：**事务T对数据对象A加上X锁，事务T可以读A也可以修改A，其他事务不能再对A加任何锁，直到T释放A上的锁，这保证了其他事务在T释放A上的锁之前不能在读取和修改A。







# 15.解释一下MVCC

全称  Multi-VeVersion Concurrency Control，**多版本并发控制**。指维护一个数据的多个版本，使得**读写操作没有冲突**，快照读为MySQL实现MVCC提供了一个**非阻塞读**功能。MVCC的具体实现，还需要依赖于数据库记录中的**三个隐式字段**、**undolog日志**、**readView**。

> 三个隐藏字段

| 隐藏字段    | 含义                                                         |
| ----------- | ------------------------------------------------------------ |
| DB_TRX_ID   | 最近修改事务ID，记录插入这条记录或最后一次修改该记录的事务ID。 |
| DB_ROLL_PTR | 回滚指针，指向这条记录的上一个版本，用于配合undo log，指向上一个版本。 |
| DB_ROW_ID   | 隐藏主键，如果表结构没有指定主键，将会生成该隐藏字段。       |

> undolog

回滚日志，在insert、update、delete的时候产生的便于数据回滚的日志。

- 当insert的时候，产生的undo log日志只在回滚时需要，在事务提交后，可被立即删除。

- 而update、delete的时候，产生的undo log日志不仅在回滚时需要，在快照读时也需要，不会立即被删除。

> Read View

ReadView（读视图）是 快照读  SQL执行时MVCC提取数据的依据，记录并维护系统当前活跃的事务（未提交的）id。



| 字段           | 含义                                                 |
| -------------- | ---------------------------------------------------- |
| m_ids          | 当前活跃的事务ID集合                                 |
| min_trx_id     | 最小活跃事务ID                                       |
| max_trx_id     | 预分配事务ID，当前最大事务ID+1（因为事务ID是自增的） |
| creator_trx_id | ReadView创建者的事务ID                               |



**而在readview中就规定了版本链数据的访问规则：**

trx_id 代表当前undolog版本链对应事务ID。	

| 条件                             | 是否可以访问                              | 说明                                       |
| -------------------------------- | ----------------------------------------- | ------------------------------------------ |
| trx_id ==creator_trx_id          | 可以访问该版本                            | 成立，说明数据是当前这个事务更改的。       |
| trx_id < min_trx_id              | 可以访问该版本                            | 成立，说明数据已经提交了。                 |
| trx_id > max_trx_id              | 不可以访问该版本                          | 成立，说明该事务是在ReadView生成后才开启。 |
| min_trx_id <=trx_id <=max_trx_id | 如果trx_id不在m_ids中，是可以访问该版本的 | 成立，说明数据已经提交。                   |



不同的隔离级别，生成ReadView的时机不同：

- **RC**(READ COMMITTED)：在事务中每一次执行快照读时生成ReadView。
- **RR** (REPEATATATABLE READ)：仅在事务中第一次执行快照读时生成ReadView，后续复用该ReadView。







# 注：

表中的数据会存储到磁盘中，由于MySql的特性一定会有按照主键构造出一个聚簇索引出来，主键的值就是索引的Key值（是指索引的key）

”每次按照主键去查询的时候，应该是会按照表中维护的索引结构，把要查询的条件的值与索引的key值进行比较，最终找到行值“




# 基础SQL

参考博客：https://blog.csdn.net/zzvar/article/details/115675248
